package  {		import starling.core.Starling;	import starling.display.Sprite;	import starling.display.Button;	import starling.display.MovieClip;	import starling.text.TextField;    import starling.textures.Texture;	import starling.textures.TextureAtlas;	import starling.events.Event;	import starling.events.TouchEvent;	import starling.events.TouchPhase;	import starling.events.KeyboardEvent;	import starling.events.TouchEvent;	import starling.events.Touch;	import flash.display.Bitmap;   		public class Space extends Sprite{				private var rowNum:int;				//row coordinate		private var colNum:int;				//column coordinate		private var revealedNum:int;		//the number that will appear if this instance is clicked and there are 'X' mines next to it		private var revealed:Boolean;		//this regulates		private var containsMine:Boolean;	//set to true if this instance contains a mine		private var marked:Boolean;			//whether or not the space has been marked by the player		private var numNeighbors:int;		//how many neghbors this space has				var _texture:Texture;				//rewritable Texture object		var _data:XML;						//rewritable XML object		var _textureAtlas:TextureAtlas;		//rewritable TextureAtlas object					var unrevealedMC:Texture;			//Texture for blank space as all start out with		var markedMC:Texture;				//texture for marked space		var revealedMC:Texture;				//texture for revealed/opened space				private var button:Button;			//The button object that will be the rot of the Space class's interactivity				[Embed(source = "MinesweeperGame.xml", mimeType = "application/octet-stream")]		private var spriteData:Class;		//spriteData for textures				[Embed(source = "MinesweeperGame.png")]		private var spritePNG:Class;		//sprite image for textures										public function Space(rNum:int, cNum:int) { 		//this takes in the coordinate values as parameters, initializes variables			super();			//addEventListener(Event.ADDED_TO_STAGE, init);			init();			rowNum = rNum;			colNum = cNum;			revealedNum = 0;			numNeighbors = 0;			revealed = false;			containsMine = false;			marked = false;		}				public function init():void{			//initializes new textures for current button			_texture = Texture.fromBitmap(new spritePNG());			_data = XML(new spriteData());			_textureAtlas = new TextureAtlas(_texture, _data);						unrevealedMC = _textureAtlas.getTexture("unrevealedMC");			markedMC = _textureAtlas.getTexture("markedMC");			revealedMC = _textureAtlas.getTexture("revealedMC");						button = new Button(unrevealedMC, "");			button.addEventListener(TouchEvent.TOUCH, determineTouch);			addChild(button);					}				public function revealSpace():void{			//this opens up the space, showing the number underneath			button.upState = revealedMC;			if(numNeighbors > 0) button.text = numNeighbors.toString();			revealed = true;		}				public function getMarked():Boolean{			return marked;		}				public function getRevealed():Boolean{			return revealed;		}				public function giveMine():void{			containsMine = true;		}				public function setNeighbors(numNei:int):void{			numNeighbors = numNei;		}				public function getNeighbors():int{			return numNeighbors;		}				public function getMine():Boolean{			return containsMine;		}				public function determineTouch(event:TouchEvent):void{			//this determines which touch event is being received, and only reacts to the appropriate one			var touch:Touch = event.getTouch(this);			if(touch !== null){				if(touch.phase == TouchPhase.ENDED){					if(Game.markState == true){						//if a key is being held down and a space is clicked on, toggle to the "marked" texture						toggleMarked();					}					else{						if(containsMine == true){							//if a key is not being held down and a mine is clicked on, the game ends 							(this.parent as Game).endGame();						}						else{							//if a key is not being held down and a space is clicked on, that space is opened							(this.parent as Game).openSpaces(rowNum, colNum);						}					}				}			}		}				public function toggleMarked():void{			//this toggles the button as being marked or not			marked = !marked;			if(marked == true) button.upState = markedMC;			else button.upState = unrevealedMC;		}			}	}