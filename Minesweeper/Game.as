package {		import starling.display.Sprite;	import starling.text.TextField;	import starling.display.MovieClip;	import starling.core.Starling;	import starling.events.KeyboardEvent;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import feathers.controls.Button;	import feathers.controls.ButtonGroup;	import feathers.controls.Label;	import feathers.events.FeathersEventType;	import feathers.data.ListCollection;	import feathers.layout.AnchorLayout;	import feathers.layout.AnchorLayoutData;	import feathers.themes.MetalWorksMobileTheme;	import starling.events.Event;	import starling.events.TouchEvent;	import starling.events.EventDispatcher;	import starling.display.Button;	//import starling.display.Button;			public class Game extends Sprite {				private var spaceArray:Array;	//this will contain the first dimension of the array		private var colTotal:Number;	//amount of columns in the field		private var rowTotal:Number;	//amount of rows in the field		public static var markState:Boolean;	//set to true if a key is held down, allowing state change		private var diffButtonGroup:ButtonGroup;	//button group for difficult		private var difficulty:int;		//difficulty set		private var winButton:Button;	//shown when player wins game		private var loseButton:Button;	//shown when player loses game		private var markText:TextField;						public function Game() {			//constructor code			colTotal = 15;			rowTotal = 10;			markState = false;						new MetalWorksMobileTheme();			init();		}				public function init():void{						if(winButton != null){				this.removeChild(winButton);				winButton = null;			}						if(loseButton != null){				this.removeChild(loseButton);				loseButton = null;			}						if(markText != null){				this.removeChild(markText);				markText = null;			}						diffButtonGroup = new ButtonGroup();			diffButtonGroup.dataProvider = new ListCollection(			[				{ label: "Easy", triggered: chooseDifficulty },				{ label: "Medium", triggered: chooseDifficulty },				{ label: "Hard", triggered: chooseDifficulty },			]);						const groupLayoutData:AnchorLayoutData = new AnchorLayoutData();			groupLayoutData.horizontalCenter = 0;			groupLayoutData.verticalCenter = 0;			diffButtonGroup.layoutData = groupLayoutData;			addChild(diffButtonGroup);			Starling.current.stage.addEventListener(KeyboardEvent.KEY_DOWN, markKeyTrue);			Starling.current.stage.addEventListener(KeyboardEvent.KEY_UP, markKeyFalse);		}				public function initializeBoard():void{			spaceArray = new Array();			markText = new TextField(530, 30, "Hold any key and click a space to mark it. " + difficulty + " mines total on this difficulty setting.");			markText.x = 10;			markText.y = 360;			markText.color = 0x00FF00;			markText.autoSize;			addChild(markText);						for(var i:int = 0; i < rowTotal; i++){				spaceArray[i] = new Array();				for(var j:int = 0; j < colTotal; j++){					var space:Space = new Space(i, j);					spaceArray[i][j] = space;					addChild(space);					space.x = (j * 30) + 50;					space.y = (i * 30) + 50;				}			}						while(difficulty > 0){				var randRow = int(Math.floor(Math.random() * rowTotal));	//set row value				var randCol = int(Math.floor(Math.random() * colTotal));	//set column value				if(spaceArray[randRow][randCol].getMine() == false){		//this prevents duplicates					spaceArray[randRow][randCol].giveMine();				//place a mine into the space					difficulty--;				}			}						setNumbers();		}				public function setNumbers():void{			var spaceNum:int = 0;			for(var l:int = 0; l < rowTotal; l++){				for(var m:int = 0; m < colTotal; m++){					spaceNum = 0;					if(spaceArray[l-1] != null) if(spaceArray[l-1][m-1] != null  &&  spaceArray[l-1][m-1].getMine() == true) spaceNum++;					if(spaceArray[l-1] != null) if(spaceArray[l-1][m] != null  &&  spaceArray[l-1][m].getMine() == true) spaceNum++;					if(spaceArray[l-1] != null) if(spaceArray[l-1][m+1] != null  &&  spaceArray[l-1][m+1].getMine() == true) spaceNum++;					if(spaceArray[l] != null) if(spaceArray[l][m-1] != null  &&  spaceArray[l][m-1].getMine() == true) spaceNum++;					if(spaceArray[l] != null) if(spaceArray[l][m+1] != null  &&  spaceArray[l][m+1].getMine() == true) spaceNum++;					if(spaceArray[l+1] != null) if(spaceArray[l+1][m-1] != null  &&  spaceArray[l+1][m-1].getMine() == true) spaceNum++;					if(spaceArray[l+1] != null) if(spaceArray[l+1][m] != null  &&  spaceArray[l+1][m].getMine() == true) spaceNum++;					if(spaceArray[l+1] != null) if(spaceArray[l+1][m+1] != null  &&  spaceArray[l+1][m+1].getMine() == true) spaceNum++;					spaceArray[l][m].setNeighbors(spaceNum);				}			}		}				public function chooseDifficulty(event:Event):void{			//this will set the difficulty to 10, 20, or 30			//the number corresponds to the total number of mines places on the board			var newButton:Button = Button(event.currentTarget);			if(newButton.label == "Easy"){				difficulty = 10;			}			else if(newButton.label == "Medium"){				difficulty = 20;			}			else if(newButton.label == "Hard"){				difficulty = 30;			}			initializeBoard();			removeChild(diffButtonGroup);		}				public function markKeyTrue(event:KeyboardEvent):void {			//hold down any key on keyboard and click to mark space			if(event.keyCode > 0){				markState = true;			}		}				public function markKeyFalse(event:KeyboardEvent):void {			//hold down any key on keyboard and click to unmark space			if(event.keyCode > 0){				markState = false;			}		}				public function openSpaces(n:int, o:int):void{			//this will attempt to open the current space, and any neighboring space if avilable			if((spaceArray[n] != null) && (spaceArray[n][o] != null)){				if(spaceArray[n][o].getNeighbors() == 0){					spaceArray[n][o].revealSpace();					if(spaceArray[n-1] != null){						if(spaceArray[n-1][o-1] != null  &&  spaceArray[n-1][o-1].getMarked() == false  &&  spaceArray[n-1][o-1].getRevealed() == false) openSpaces(n-1, o-1);						if(spaceArray[n-1][o] != null  &&  spaceArray[n-1][o].getMarked() == false  &&  spaceArray[n-1][o].getRevealed() == false) openSpaces(n-1, o);						if(spaceArray[n-1][o+1] != null  &&  spaceArray[n-1][o+1].getMarked() == false  &&  spaceArray[n-1][o+1].getRevealed() == false) openSpaces(n-1, o+1);					}					if(spaceArray[n][o-1] != null  &&  spaceArray[n][o-1].getMarked() == false  &&  spaceArray[n][o-1].getRevealed() == false) openSpaces(n, o-1);					if(spaceArray[n][o+1] != null  &&  spaceArray[n][o+1].getMarked() == false  &&  spaceArray[n][o+1].getRevealed() == false) openSpaces(n, o+1);					if(spaceArray[n+1] != null){						if(spaceArray[n+1][o-1] != null  &&  spaceArray[n+1][o-1].getMarked() == false  &&  spaceArray[n+1][o-1].getRevealed() == false) openSpaces(n+1, o-1);						if(spaceArray[n+1][o] != null  &&  spaceArray[n+1][o].getMarked() == false  &&  spaceArray[n+1][o].getRevealed() == false) openSpaces(n+1, o);						if(spaceArray[n+1][o+1] != null  &&  spaceArray[n+1][o+1].getMarked() == false  &&  spaceArray[n+1][o+1].getRevealed() == false) openSpaces(n+1, o+1);					}				}				else if(spaceArray[n][o].getNeighbors() > 0){					spaceArray[n][o].revealSpace();				}				else if(spaceArray[n][o].getNeighbors() < 0){					//this condition means that the current space contains a mine, and therefore nothing should be done				}			}						winCondition(); //checks if the user has won the game or not		}				public function winCondition():Boolean{			//this checks the board each time a space is opened up, and determines if any unopened non-mine spaces are left			var winGame = true;			for(var p:int = 0; p < rowTotal; p++){				for(var q:int = 0; q < colTotal; q++){					if(spaceArray[p][q].getMine() == false){						if(spaceArray[p][q].getRevealed() == false){							winGame = false;							break;						}					}				}			}			if(winGame == true){				//if the user has won the game, then the board must be cleared, user is notified, and game starts again				while(this.numChildren > 0){					this.removeChildAt(0);				}				winButton = new Button();				winButton.label = "You Won! Click to Play Again!";				this.addChild(winButton);				winButton.addEventListener(Event.TRIGGERED, init);			}						return winGame;		}				public function endGame():void{			//ends the game if a bomb is clicked on. The board gets cleared, user is notified, and the game starts again			while(this.numChildren > 0){				this.removeChildAt(0);			}						loseButton = new Button();			loseButton.label = "You have Lost! Click to Play Again";			this.addChild(loseButton);			loseButton.addEventListener(Event.TRIGGERED, init);					}	}}